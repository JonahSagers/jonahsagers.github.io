<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Floating Bubble</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: #f0f8ff;
    }
    .bubble {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translate(-50%, 0);
    }
    /* Prevent text/image selection inside bubbles so pointer dragging is uninterrupted */
    .bubble, .bubble * {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
    .bubble img {
      -webkit-user-drag: none;
    }
    .inner-mask {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    .inner-mask img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .bg-green {
    background-color: #73e380; /* Your custom color */
  }
  </style>
</head>
<body>
  <!-- Commencement -->
  <div class="bubble bg-danger text-white rounded-circle d-flex justify-content-center align-items-center"
      style="width: 250px; height: 250px; --xPos: 0.2; --yPos: 0.3;">

    <div class="inner-mask inner-circle bg-white rounded-circle d-flex justify-content-center align-items-center" 
        style="width: 90%; height: 90%; position: relative;">

      <img src="./assets/images/Commencement.jpeg" class="item thumb rounded float-left" 
          style="--xPos: -0.09; --yPos: -0.08; --scaled: 0.75; width: 100%; height: 100%; object-fit: cover; z-index: 2; position: absolute;">
          
      <img src="./assets/images/CommencementOverview.jpeg" class="item rounded float-left" 
          style="--xPos: -0.12; --yPos: 0.13; width: 75%; height: 65%; object-fit: cover; position: absolute;">

      <div class="item text-dark" 
          style="position: absolute; --xPos: 0.12; --yPos: 0.02; width: 160px; height: 200px;">
            Voted by my peers to be commencement speaker for the founding class of the Mastery School of Hawken.
      </div>
    </div>
  </div>

  <!-- Kent State -->
  <div class="bubble bg-primary text-white rounded-circle d-flex justify-content-center align-items-center"
      style="width: 250px; height: 250px; --xPos: 0.25; --yPos: 0.7;">

    <div class="inner-mask inner-circle bg-white rounded-circle d-flex justify-content-center align-items-center" 
        style="width: 90%; height: 90%; position: relative;">

      <img src="./assets/images/KentStatePhysical.png" class="item thumb rounded float-left" 
          style="--xPos: -0.1; --yPos: -0.1; --scaled: 0.75; width: 100%; height: 100%; object-fit: cover; z-index: 2; position: absolute;">
          
      <img src="./assets/images/DroneVR.gif" class="item rounded float-left" 
          style="--xPos: -0.11; --yPos: 0.11; width: 80%; height: 80%; object-fit: cover; position: absolute;">

      <div class="item text-dark" 
          style="position: absolute; --xPos: 0.14; --yPos: 0.01; width: 150px; height: 220px;">
            Cognitive Robotics at Kent State!
            I Developed gesture based control methods for drone swarms, and drafted an IEEE paper on the process.
      </div>
    </div>
  </div>

  <!-- Lifesteal -->
  <div class="bubble bg-green text-white rounded-circle d-flex justify-content-center align-items-center"
      style="width: 175px; height: 175px; --xPos: 0.75; --yPos: 0.2;">

    <div class="inner-mask inner-circle bg-white rounded-circle d-flex justify-content-center align-items-center" 
        style="width: 90%; height: 90%; position: relative;">

      <img src="./assets/images/SpokeTeam.png" class="item rounded float-left" 
          style="--xPos: -0.13; --yPos: -0.14; width: 100%; height: 100%; object-fit: cover; z-index: 2; position: absolute;">
          
      <img src="./assets/images/Lifesteal.png" class="item rounded float-left" 
          style="--xPos: -0.13; --yPos: 0.14; width: 100%; height: 90%; object-fit: cover; position: absolute;">

      <div class="item text-dark" 
          style="position: absolute; --xPos: 0.14; --yPos: 0.02; width: 130px; height: 220px;">
            Administrator for the SpokeMC 100 player civilization events. 15,000 players, 9.6 million views and counting.
      </div>
    </div>
  </div>
  <!-- Tech Corps -->
  <div class="bubble bg-danger text-white rounded-circle d-flex justify-content-center align-items-center"
      style="width: 150px; height: 150px; --xPos: 0.8; --yPos: 0.5;">

    <div class="inner-mask inner-circle bg-white rounded-circle d-flex justify-content-center align-items-center" 
        style="width: 90%; height: 90%; position: relative;">

      <img src="./assets/images/TechCorps.png" class="item rounded float-left" 
          style="--xPos: -0.15; --yPos: -0.15; width: 100%; height: 100%; object-fit: cover; z-index: 2; position: absolute;">
          
      <img src="./assets/images/TechieCamp.jpeg" class="item rounded float-left" 
          style="--xPos: -0.15; --yPos: 0.15; width: 100%; height: 90%; object-fit: cover; position: absolute;">

      <div class="item text-dark" 
          style="position: absolute; --xPos: 0.15; --yPos: 0; width: 130px; height: 200px;">
            Youngest educator ever hired by TechCORPS, teaching robotics in outreach programs around Cleveland.
      </div>
    </div>
  </div>
<!-- 
  <div class="bubble bg-primary text-white rounded-circle d-flex justify-content-center align-items-center"
      style="width: 150px; height: 150px; --xPos: 0.4; --yPos: 0.5;">

    <div class="inner-mask inner-circle bg-white rounded-circle d-flex justify-content-center align-items-center" 
        style="width: 90%; height: 90%; position: relative;">

      <img src="./assets/images/Commencement.jpeg" class="item rounded float-left" 
          style="--xPos: -0.15; --yPos: -0.15; width: 100%; height: 100%; object-fit: cover; z-index: 2; position: absolute;">
          
      <img src="./assets/images/Commencement_overview.jpeg" class="item rounded float-left" 
          style="--xPos: -0.15; --yPos: 0.15; width: 100%; height: 90%; object-fit: cover; position: absolute;">

      <div class="item text-dark card" 
          style="position: absolute; --xPos: 0.15; --yPos: 0; width: 120px; height: 150px;">
            Lorem Ipsum
      </div>
    </div>
  </div> -->


  <script>
    // Simple Perlin noise generator
    class Perlin {
      constructor() {
        this.grad = [];
        for (let i = 0; i < 256; i++) {
          this.grad[i] = Math.random() * 2 - 1;
        }
      }

      fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      }

      lerp(a, b, t) {
        return a + t * (b - a);
      }

      noise(x) {
        let xi = Math.floor(x) & 255;
        let xf = x - Math.floor(x);
        let g1 = this.grad[xi];
        let g2 = this.grad[(xi + 1) & 255];
        let dot1 = g1 * xf;
        let dot2 = g2 * (xf - 1);
        let u = this.fade(xf);
        return this.lerp(dot1, dot2, u);
      }
    }

    const perlin = new Perlin();
    const bubbles = document.getElementsByClassName('bubble');
    const xPercent = 0.7;
    const yPercent = 0.9;

    for (const bubble of bubbles){
      // bubble.xPos = (window.innerHeight * (Math.random() * yPercent)); 
      // bubble.yPos = (window.innerWidth/2 * (Math.random() * xPercent * 2 - xPercent));
      bubble.t = Math.random() * 100;
      bubble.ySpeed = 0.2 + Math.random() * 0.2;
      bubble.xPos = (parseFloat(bubble.style.getPropertyValue("--xPos")) - 0.5) * window.innerWidth - perlin.noise(bubble.t) * 500;
      bubble.yPos = parseFloat(bubble.style.getPropertyValue("--yPos")) * window.innerHeight;
      bubble.height = parseFloat(bubble.style.getPropertyValue("height"));
      bubble.size = 1;
      bubble.items = bubble.querySelectorAll('.item');
      for(const item of bubble.items){
        item.xPos = item.style.getPropertyValue("--xPos") * bubble.height;
        item.yPos = item.style.getPropertyValue("--yPos") * bubble.height;
        item.xNow = 0;
        item.yNow = 0;
        item.size = 1;
        if(item.classList.contains("thumb")){
          item.scalar = parseFloat(item.style.getPropertyValue("--scaled"));
        } else {
          item.scalar = 1;
        }
        // Prevent browser selection/drag of inner content so pointer dragging always starts on the bubble
        try {
          item.draggable = false;
        } catch (e) {}
        item.addEventListener('dragstart', (ev) => ev.preventDefault());
      }
      // setup dragging/inertia state
      bubble.style.touchAction = 'none'; // allow pointer events to handle pan
      bubble.isDragging = false;
      bubble.dragBlend = 0; // 0 = no drag influence, 1 = fully controlled by drag/inertia
      bubble.velocity = {x:0, y:0};
      bubble._lastPositions = [];

      // pointer handlers
      bubble.addEventListener('pointerdown', (e) => {
        bubble.setPointerCapture(e.pointerId);
        bubble.isDragging = true;
        bubble.dragBlend = 1;
        // starting offset mapping: translate center-based xNoise to clientX
        const rect = bubble.getBoundingClientRect();
        // pointer-based center
        bubble._dragOffset = {x: e.clientX - (window.innerWidth/2 + (bubble.xNoise || 0)), y: e.clientY - bubble.yPos};
        bubble._lastPositions = [{t: performance.now(), x: e.clientX, y: e.clientY}];
      });

      bubble.addEventListener('pointermove', (e) => {
        if(!bubble.isDragging) return;
        const now = performance.now();
        // map pointer to scene coordinates
        const clientX = e.clientX;
        const clientY = e.clientY;

        // compute target xNoise (pixels from center)
        const targetXNoise = clientX - window.innerWidth/2 - bubble._dragOffset.x;
        // immediate update so the user sees follow
        bubble.xNoise = targetXNoise;
        bubble.yPos = clientY - bubble._dragOffset.y;

        // store last positions for velocity calc (keep ~100ms)
        bubble._lastPositions.push({t: now, x: clientX, y: clientY});
        while(bubble._lastPositions.length > 5 || (now - bubble._lastPositions[0].t) > 120){
          bubble._lastPositions.shift();
        }
      });

      function endDrag(e){
        if(!bubble.isDragging) return;
        bubble.isDragging = false;
        const now = performance.now();
        const positions = bubble._lastPositions;
        if(positions.length >= 2){
          const first = positions[0];
          const last = positions[positions.length - 1];
          const dt = Math.max(1, last.t - first.t);
          // px per ms
          const vx = (last.x - first.x) / dt;
          const vy = (last.y - first.y) / dt;
          // convert to px per frame approx (assuming 16ms frame)
          bubble.velocity.x = vx * 16;
          bubble.velocity.y = vy * 16;
        }
        // Update the bubble's resting base so it doesn't snap back to Perlin position
        // Compute a new xPos such that perlin.x + noise == current xNoise
        try {
          if(typeof bubble.xNoise === 'number'){
            bubble.xPos = bubble.xNoise - perlin.noise(bubble.t) * 150;
          }
        } catch (err) {
          // ignore if perlin isn't available for some reason
        }

        bubble._lastPositions = [];
      }

      bubble.addEventListener('pointerup', endDrag);
      bubble.addEventListener('pointercancel', endDrag);
      bubble.addEventListener('lostpointercapture', endDrag);

      console.log(bubble.items);
    }

    function animate() {
      for(const bubble of bubbles) {
        if(bubble.matches(':hover')){
          bubble.style.setProperty("z-index", 10);
          mult = 6 - bubble.height/75;
        } else {
          bubble.style.setProperty("z-index", 1);
          mult = 1;
        }
        // compute perlin float position
        const perlinX = bubble.xPos + perlin.noise(bubble.t) * 150;
        const perlinYSpeed = bubble.ySpeed / mult;

        // If dragging, we override positions. If inertia running, we advance using velocity and decay it.
        if(bubble.isDragging){
          // while dragging, xNoise/yPos are set in pointermove handler
          // keep perlin t progression slowed so motion looks natural
          bubble.t += 0.0005 / mult;
        } else if(bubble.dragBlend > 0){
          // apply inertia: update positions by velocity
          bubble.xNoise = (bubble.xNoise || perlinX) + bubble.velocity.x;
          bubble.yPos = bubble.yPos + bubble.velocity.y;

          // decay velocity (exponential)
          const decay = 0.95; // per frame multiplier
          bubble.velocity.x *= decay;
          bubble.velocity.y *= decay;

          // blend drag influence down over time so perlin returns control
          bubble.dragBlend *= 0.96;
          if(Math.hypot(bubble.velocity.x, bubble.velocity.y) < 0.05) bubble.dragBlend = 0;

          // when blend is low, start re-aligning to perlin
          if(bubble.dragBlend <= 0.01){
            bubble.dragBlend = 0;
            // let perlin resume gradually by aligning xNoise/yPos to perlin positions
            bubble.xNoise = perlinX;
          } else {
            // mix perlin and inertia for smooth handoff
            bubble.xNoise = bubble.xNoise * bubble.dragBlend + perlinX * (1 - bubble.dragBlend);
          }

          // advance perlin time mildly while inertia continues
          bubble.t += 0.001 / mult;
        } else {
          // normal floating
          bubble.xNoise = perlinX;
          bubble.yPos -= perlinYSpeed; // upward speed
        }

        bubble.size += (mult  - bubble.size) / 7;

        // Reset if the bubble floats off the top (only if not currently being dragged)
        if(!bubble.isDragging){
          if(bubble.yPos < -bubble.height) {
            bubble.yPos = window.innerHeight;
          }
          if(mult > 1 && bubble.yPos > window.innerHeight - (bubble.height * bubble.size / 1.5)){
            bubble.yPos += (window.innerHeight - (bubble.height * bubble.size / 1.5) - bubble.yPos)/20;
          } else if(mult > 1 && bubble.yPos < bubble.height * bubble.size / 3){
            bubble.yPos += ((bubble.height * bubble.size / 3) - bubble.yPos)/20;
          }
          if(bubble.xPos < -window.innerWidth / 2 + (bubble.height * bubble.size / 2)){
            bubble.xPos += (-window.innerWidth / 2 + (bubble.height * bubble.size / 2) - bubble.xPos) / 20;
          } else if(bubble.xPos > window.innerWidth / 2 - (bubble.height * bubble.size / 2)){
            bubble.xPos += (window.innerWidth / 2 - (bubble.height * bubble.size / 2) - bubble.xPos) / 20;
          }
        } else {
          console.log((-window.innerWidth / 2 - (bubble.height * bubble.size / 1.5) - bubble.xPos) / 20);
        }
        

        for(const item of bubble.items){
          //using a square ease multiplies with the parent and creates a cubic
          //potentially swap this out for a lerp
          if(mult > 1){
            item.xNow += (item.xPos - item.xNow) / 7;
            item.yNow += (item.yPos - item.yNow) / 7;
          } else {
            item.xNow += (-item.xNow) / 7;
            item.yNow += (-item.yNow) / 7;
          }
          //not entirely sure why, but the updated scaling function would break text objects specifically
          if(item.scalar != 1){
            item.size = (1/(bubble.size/2+0.5)+0.02) * (1 - (1 - item.scalar) * (item.yNow / item.yPos));
          } else {
            item.size = 1/(bubble.size/2+0.5)+0.02;
          }
          
          
          item.style.transform = `translate(${item.xNow}%, ${item.yNow}%) scale(${item.size})`;
        }


  bubble.style.transform = `translate(calc(-50% + ${bubble.xNoise}px), ${bubble.yPos}px) scale(${bubble.size})`;

        // bubble.style.setProperty("--xPos", bubble.xNoise);
        // bubble.style.setProperty("--yPos", bubble.yPos);

        

        // advance the perlin time normally when not dominated by dragging/inertia
        if(!bubble.isDragging && bubble.dragBlend === 0){
          bubble.t += 0.0015 / mult;
        }
      }
      requestAnimationFrame(animate);
    }

    animate();
  </script>

</body>
</html>
